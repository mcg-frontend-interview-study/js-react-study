## 들어가기
현대 FE 개발에서 ‘불변 객체’ 개념은 빈번하게 사용된다. 하지만 그 범용성에 비해 불변 객체를 만드는 것은 생각보다 쉽지 않다. 원시 타입과 달리 객체는 const로 선언해도 내부 프로퍼티를 자유롭게 변경할 수 있기 때문이다. 
객체가 왜 이렇게 동작하는지, 원시 타입과 참조 타입의 명확한 차이는 무엇인지를 JS의 메모리 할당을 통해 살펴보기로 했다.

<br>

## 원시 타입이 저장되는 방식

JS의 타입은 크게 원시 타입과 참조 타입으로 나뉜다. 
참조 타입은 이름부터 ‘참조’이므로 무조건 참조를 사용할 것 같다. 그렇다면 원시 타입은 메모리 주소 참조가 일어나지 않을까?
원시 타입 중 하나인 String 변수를 저장하는 과정을 살펴보자.

```tsx
var a = 'A';
```

1. **Lexical Environment**에 식별자 a가 저장된다.
2. ‘A’를 저장하기 위한 메모리를 **스택**에서 확보한다.
3. Lexical Envionment에서 식별자 a와 ‘A’가 저장된 메모리 주소를 **매핑**한다.

값 ‘A’가 식별자 a와 같은 공간에 저장되지 않기 때문에 값에 접근하려면 lexical environment에서 값이 저장된 **메모리 주소를 참조**해야 한다. 즉 원시 타입을 사용할 때도 메모리 참조가 1번은 일어나는 셈이다. 

그렇다면 왜 값을 바로 저장하지 않고 번거롭게 주소값을 연결하는 과정을 거치는 것일까? 이는 JS의 **자유로운 타입 변화**를 지원하되 **메모리를 절약**하기 위해서이다.

식별자와 값이 같은 메모리 공간에 저장되어 있다면, 값을 다른 타입으로 수정할 때마다 새 값의 크기에 맞춰 메모리 공간을 늘이거나 줄여야 한다. 매번 새 값의 크기를 계산하고 새로 할당하는 것보다는 새 값을 새로운 공간에 할당하고 참조를 바꿔주기만 하는 방식이 더 경제적일 것이다. 

같은 값을 여러 번 할당할 때도 참조 방식이 유용하다. 식별자와 값을 한꺼번에 저장한다면 같은 값을 사용함에도 불구하고 그 값을 모든 변수에 매번 담아야 한다. 반면 참조 방식을 사용한다면 실제 값을 하나만 저장해둬도 모든 변수에 값을 할당할 수 있다. 모든 변수들이 그 값의 주소를 참조해서 사용할 수 있기 때문이다. 이를 통해 불필요한 메모리 할당을 줄일 수 있다.

이 섹션의 내용을 정리하면 아래와 같다. 

- 원시 타입의 값은 스택에 저장된다.
- 원시 값에 접근할 때도 참조를 사용한다.
- 원시 값은 불변이므로 한 번 생성된 원시값은 수정할 수 없다. 단지 생성과 삭제만 일어날 뿐이다.

<br>

## 불변값과 상수

원시 타입의 값이 저장되는 방식과 그 값이 불변인 이유를 살펴보았다. 
다만 JS에는 ‘불변’을 다루는 개념이 또 있다. 바로 `const` 키워드인데, ‘변하지 않는다’는 개념이 두 군데에서 등장해 혼란의 여지가 있다.

두 개념의 비교에 앞서 불변값 개념을 확실히 하고자 한다. 이 코드가 바로 원시 값을 직접적으로 바꾸려 하는 예시이다.

```tsx
let abc = 'abc';
abc[1] = 'B'; 

console.log(abc); // abc
```

에러는 발생하지 않지만 1번 인덱스의 값이 대문자로 변하지 않고 여전히 `"abc"` 를 유지한다.
JS는 불변값인 문자열을 변경하려고 하면 내부적으로 해당 코드를 무시하므로 2번째 줄의 동작은 무효가 된다. (런타임 에러를 내지 않는 이유는 JS의 철학이 느슨한 타입과 개발자 친화적인 문법, 웬만해서는 중단되지 않는 실행이기 때문이라고 한다)  

이 코드도 위의 코드와 같은 결과(`"aBc"`)를 위한 것이다. 하지만 이 코드는 의도한대로 잘 동작한다.

```tsx
let abc = 'abc';

console.log(abc.replace('b', 'B')); // aBc
```

JS의 문자열 내장 함수들은 불변값인 문자열을 다루기 위해 원본 값에 접근한 다음, 그 값을 직접 수정하지 않고 새로운 문자열을 가공해 리턴하기 때문이다.  

그렇다면 아래 예시는 `abc[1]  = ‘B’`와 뭐가 다르길래 잘 동작하는 걸까?

```tsx
let a = 'A';
a = a + 'BC';
console.log(a); // 'ABC'

// const로 바꿀 경우 TypeError: Assignment to constant variable 발생
```

그 이유는 “**리터럴 값**”의 변경 가능 여부와 “이미 매핑이 이루어졌던 **식별자**에 새 값을 넣을 수 있느냐”가 다르기 때문이다. 

앞서 원시값의 할당 과정을 설명했다. 그 과정을 더 자세히 살펴보면 아래와 같다.
먼저 a가 lexical environment에 저장되고, 문자열 리터럴은 스택에 할당된다. 이후 두 값이 매핑된다.

```tsx
// 간소화된 lexical environment 
Lexical Environment:
{
  'a': 0x001, 
}

// 스택 
주소    값
0x001   'A'
```

이 상황에서 `a = a + "BC"`를 실행하면 JS는 스택에 문자열 ABC를 새로 만들어 저장하고, 식별자 a가 가리키던 주소값을 ABC를 저장한 주소로 바꾼다. 

```tsx
Lexical Environment:
{
  'a': 0x002, 
}

// 스택 
주소    값
0x002   'ABC'
```

따라서 리터럴 값인 문자열은 변하지 않았다(정확히는 원래 있던 값이 수정된 것이 아니다). 최종 결과로 ABC가 출력되긴 했지만 이 값은 A가 변한 게 아니라 A에 BC를 더한 새로운 값이기 때문이다.
새 값을 만든 뒤 식별자 a에 이 값이 담긴 새로운 주소를 할당하는데, `let`으로 a를 선언했으므로 이 할당 과정이 오류 없이 이루어진다. `const`였다면 에러가 났을 것이다. 

이건 맨 처음의 예시인데, 키워드를 `const`로 변경해도 `let`일 때와 똑같이 실행된다. 리터럴 값의 변경에 대한 예시이지, 기존 식별자에 새로운 값을 할당하는 게 아니기 때문에 키워드 종류는 중요하지 않은 것이다.

```tsx
const abc = 'abc';
abc[1] = 'B'; 

console.log(abc); // abc
```

<br>

## 참조 타입이 저장되는 방식과 가변값
이제 참조 타입이 어떻게 저장되는지를 살펴보자. 참조 타입은 이름답게 참조를 여러 번 거쳐야 한다.

```tsx
var obj = { 
	a: 0, 
	b: "B", 
	c: [1, 2, 3] 
};

Lexical Environment:
{
  'obj': 0x100 
}

// 스택
주소    값
0x100   0xA0FF 

// 힙 
주소    값
0xA0FF  { a: 0x1302, b: 0xB315, c: 0xA032 }  // 객체 자체

0x1302    0                                  // 프로퍼티 'a'의 값

0xB315    "B"                                // 프로퍼티 'b'의 값

0xA032    [0xFF04, 0x1D05, 0x5C06]           // 배열 'c'

0xFF04    1                                  // 배열 요소 0
0x1D05    2                                  // 배열 요소 1
0x5C06    3                                  // 배열 요소 2
```

1. Lexical Environment에 식별자 obj가 저장된다.
2. obj에 할당된 값을 저장해야 하는데, 값은 참조 타입인 객체이다. 
    
    따라서 값을 저장할 메모리를 **힙**에 할당(0xA0FF)한다.
    
    obj와 매핑된 주소(0x100)에서 갖고 있는 값은 객체 정보를 저장하는 힙 메모리(0xA0FF)이다. 
    
3. obj와 직접 매핑된 힙 주소(0xA0FF)에서는 **프로퍼티들의 주소값**을 관리한다.
    
    원시 값들은 저장된 주소를 타고 가면 바로 리터럴 값이 있지만, 참조 타입인 배열을 갖고 있는 c에 대해서는 한번 더 참조가 이루어진다. 
    
    (예시에서는 객체 안의 원시값들을 힙에 저장하고 있지만 스택에 저장될 수도 있다. 참조 값이 복잡하거나 크기가 크면 힙에, 아니면 스택에 저장한다고 한다)
    

뭔가 더 복잡해졌지만 세 줄 정도로 요약해볼 수 있다. 

- 객체 식별자에 매핑된 값은 **스택** 메모리 주소이며, 스택 메모리 주소가 저장하는 값은 **힙** 주소이다.
- **힙** 주소에서는 일차적으로 객체에 딸린 프로퍼티의 값이 담긴 주소들을 저장한다.
- 저장된 주소를 타고 프로퍼티 값에 접근할 수 있다.

이렇듯 원시 타입에 비해 참조를 최소 1번 더 거치는 탓에 객체 자체는 불변으로 선언했을지라도 프로퍼티에 접근해 값을 수정할 수 있다.

```tsx
const obj = { 
	a: 0, 
	b: "B", 
	c: [1, 2, 3] 
};

obj.c = 'New String Value';
console.log(obj.c); // 'New String Value'

obj = {}; // 에러 
```

객체를 `const`로 선언했는데도 프로퍼티 값을 수정해도 오류가 나지 않고, 실제로도 변경사항이 적용된다. obj와 직접적으로 연결된 주소값 대신 간접적으로 연결된 주소값만 바꾸기 때문이다. 

```tsx
Lexical Environment:
{
  'obj': 0x100 
}

// 스택
주소    값
0x100   **0xA0FF** // 변하지 않음

// 힙 
주소    값
0xA0FF  { a: 0x1302, b: 0xB315, **c: 0x3631** }  // 객체 자체

0x1302    0                                  // 프로퍼티 'a'의 값

0xB315    "B"                                // 프로퍼티 'b'의 값

0xA032    [0xFF04, 0x1D05, 0x5C06]           // 이제 0xA032와 관련된 값들은 참조 카운트가 0이므로 **GC 수거** 예정

0xFF04    1                                  // 배열 요소 0
0x1D05    2                                  // 배열 요소 1
0x5C06    3                                  // 배열 요소 2

**0x3631    "New String Value"**                 // 프로퍼티 'c'의 새로운 값
```

하지만 새로운 객체를 할당하는 것은 객체 식별자 obj에 저장했던 힙 주소값(0xA0FF)을 바꾸는 작업이기 때문에 객체를 상수로 선언했다면 에러가 난다.

이제 ‘참조형 데이터는 가변적’이라는 말의 의미를 이해할 수 있게 되었다. 참조형 데이터에 들어가는 값들은 원시값과 달리 직접 수정할 수 있다. 

앞선 예시에서 프로퍼티 c만 변경했을 때, 다른 값들은 변하지 않았고 오직 프로퍼티 c와 관련된 값들만 변했다. 만약 참조형이 원시형과 똑같이 동작했다면 모든 값을 새로 옮겨야 했을 것이다. 이 점에서 원시값은 가변적이라는 뜻이다.

하지만 참조값 전체를 새 값으로 바꾸면 새 값으로 완전히 갈아타는 셈이 된다. 따라서 참조형을 정확히 설명하자면 ‘**참조형 데이터의 내부 데이터는 수정 가능하다**’ 라고 할 수 있겠다.

<br>

### 더 알아보기

**식별자 obj에 매핑된 주소가 스택 메모리 주소인 이유**

곧바로 힙으로 가면 편할 텐데 굳이 스택을 거치는 이유가 있다.

1. 빠른 접근
: 스택은 연속된 메모리 공간이고 LIFO 방식으로 관리되므로 힙보다 빨리 접근할 수 있다.
(힙은 가변적이므로 스택만큼 빠르게 접근하기 어렵다)

2. GC 용이
: 힙만 사용할 때는 더 이상 사용하지 않는 값을 주워가기 어렵지만, 스택 → 힙 참조를 사용하면 참조 카운트가 0인 데이터만 삭제하면 되므로 간편하다.


**객체 프로퍼티도 Lexical Environment에 저장될까?**

객체 프로퍼티는 객체 내부의 메모리에서 별도로 관리한다. Lexical과는 관련이 없다.

<br>

## 원시 타입과 참조 타입의 차이: 값 참조하기

원시 타입과 참조 타입의 차이점은 값을 참조한 뒤의 동작에서 잘 드러난다.

```tsx
var a = 10;
var b = a;

var obj1 = { c: 'c'};
var obj2 = obj1;
```

두 타입 모두 참조를 사용했으니 원본과 사본(참조로 새로 만든 변수)이 바라보는 주소는 같다.

```tsx
Lexical Environment:
{
	'a' : 0x100,
	'b' : 0x100,   // 같은 원시값을 재사용하는 최적화를 사용한다고 가정
 'obj1': 0x101,
	'obj2': 0x101,   
}

// 스택
주소    값
0x100   10
0x101   0xA0FF 

// 힙 
주소    값
0xA0FF  { c: 0xA032 }  

0xA032  'c'
```

하지만 이후 사본에 수정을 가한다면 결과가 달라진다.

```tsx
b = 15;
console.log(a === b); // false

obj2.c = 20;
console.log(obj1 === obj2) // true
```

원시 타입인 a와 b는 값의 수정이 곧 주소값의 수정이므로 바라보는 주소가 서로 달라진다. 

```tsx
Lexical Environment:
{
	'a' : 0x100,
	'b' : 0x102,   
  ...  
}

// 스택
주소    값
0x100   10
...
0x102   15
```

반면 참조 타입인 객체는 전체 객체의 주소값 변경이 없었으므로 사본의 변화가 원본에 영향을 미친다.

```tsx
Lexical Environment:
{
	...
  'obj1': 0x101,
	'obj2': 0x101,   // 전체 참조값은 동일
}

// 스택
주소    값
...
0x101   0xA0FF 
...

// 힙 
주소    값
0xA0FF  { c: **0x5B11** }  

0xA032  'c'
**0x5B11  20**
```

변한 부분은 프로퍼티 c의 주소값뿐이다. 결국 식별자 obj1, obj2 중 어느 것으로 객체 프로퍼티 값에 접근해도 같은 값을 읽게 된다.

<br>

## 얕은 복사와 깊은 복사, 그리고 참조

얕은 복사와 깊은 복사의 차이점은 다들 알고 있을 것이라고 생각한다.

얕은 복사는 최상위 값들만 독립적으로 가져오고, 중첩된 참조 타입의 값은 원본의 주소값을 그대로 사용한다. 반면 깊은 복사는 중첩된 참조값들도 주소 대신 실제 저장된 값으로 가져온다.

그렇다면 언뜻 비슷해 보이는 `copiedObj = originalObj`를 하는 것과 얕은 복사의 차이점은 무엇일까?

전자는 단순 참조로, 모든 값을 공유한다. 즉 ‘복사’가 아예 일어나지 않는다. 얕은 복사는 어쨌든 값을 복사하기는 한다. 

복사가 이루어진다는 것은 스프레드 문법과 함께 보면 더 명확해진다. 원본 객체의 값을 복사한 ‘새로운 객체’를 할당하고 있기 때문이다. 

```tsx
const original = { a: 1, b: { c: 2 } };
const shallow = { ...original }; // 얕은 복사
```

새로운 객체를 할당했으므로 식별자 original과 shallow가 가리키는 힙 메모리 주소는 다를 것이다.

```tsx
// 스택
original -> 0xA0FF
shallow -> 0xB100  // 새 객체 생성으로 힙 주소값 다름
```

문제는 사본에 어떤 값들이 복사되어 들어왔는지다.

앞서 설명했듯 얕은 복사를 하면 최상위 레벨의 값들은 그대로 복사된다.  그러나 최상위 레벨이 아닌 값들, 즉 중첩된 참조값들은 별도로 복사되지 않고 원본의 주소값을 그대로 가져온다.  

```tsx
// 스택
original -> 0xA0FF
shallow -> 0xB100  

// 힙
0xA0FF  { a: 0x1302, b: **0xC522** }
0x1302  1
0xC522  { c: 0xA032 }
0xA032  2

0xB100  { a: 0xC302, b: **0xC522** }   // 객체를 저장하는 b의 주소값이 원본과 같음

// Note: 원시값을 재활용하지 않는 경우 a의 값인 1도 처음부터 다른 곳에 할당됨
```

그래서 어떤 식별자를 사용해도 참조값에 접근하면 항상 같은 공간을 바라보게 되므로 원본과 사본 데이터가 공유된다.

```tsx
shallow.a = 'hello';
console.log(original.a) // 1 (원본은 변경되지 않음)

shallow.b.c = 20;
console.log(original.b.c); // 20 (원본도 변경됨)
```

이렇게 변경이 일어났을 때의 메모리 구조는 다음과 같다. 

```tsx
// 스택
original -> 0xA0FF
shallow -> **0xB100**  

// 힙
0xA0FF  { a: 0x1302, b: **0xC522** }
0x1302  1
0xC522  { c: 0xA032 }
0xA032  2

**0xB100  { a: 0xC302, b: 0xC522 }**   // 중첩 객체가 저장된 주소값은 여전히 원본과 같음 
0xC302  'hello'
```

<br>

## 참고
- 코어 자바스크립트
- [JS Memory Model](https://medium.com/su-s-daily-log/js-memory-model-119257cda77b)
- [Understanding Memory Leaks in Nodejs](https://blog.bitsrc.io/memory-leaks-in-nodejs-54ac7bbd4173?gi=011a49eb80e3)
- [Lexical Scope, Lexical Environment, Execution Context, Closure in JavaScript](https://dev.to/antonzo/lexical-scope-lexical-environment-execution-context-closure-in-javascript-5bn6)
